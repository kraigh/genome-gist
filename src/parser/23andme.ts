/**
 * Parser for 23andMe genome files
 *
 * 23andMe format (v5):
 * - Comment lines start with #
 * - Header line: # rsid\tchromosome\tposition\tgenotype
 * - Data lines: rsid\tchromosome\tposition\tgenotype (tab-separated)
 * - Genotypes are 2 characters (e.g., "AA", "CT") or "--" for no-call
 * - Some lines may have single character genotypes for X/Y/MT in males
 */

import type { GenomeVariant, ParseResult, ParseError } from '../types';

/**
 * Parse a 23andMe genome file
 * @param content Raw file content
 * @returns ParseResult with variants and metadata
 * @throws ParseError if file is invalid
 */
export function parse23andMe(content: string): ParseResult {
  const lines = content.split('\n');
  const variants: GenomeVariant[] = [];
  const errors: ParseError[] = [];

  let generatedAt: string | undefined;
  let build: string | undefined;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    const trimmed = line.trim();

    // Skip empty lines
    if (trimmed.length === 0) continue;

    // Parse comment lines for metadata
    if (trimmed.startsWith('#')) {
      // Extract generation date
      const dateMatch = trimmed.match(/generated by 23andMe at:\s*(.+)/i);
      if (dateMatch?.[1]) {
        generatedAt = dateMatch[1].trim();
      }

      // Extract build info
      const buildMatch = trimmed.match(/build\s+(\d+)/i);
      if (buildMatch?.[1]) {
        build = buildMatch[1];
      }

      continue;
    }

    // Parse data line
    const variant = parseDataLine(trimmed);
    if (variant) {
      variants.push(variant);
    } else if (trimmed.length > 0) {
      // Only track errors for non-empty lines that failed to parse
      errors.push({
        message: 'Failed to parse line',
        line: i + 1,
        details: trimmed.slice(0, 100),
      });
    }
  }

  // Validate we got some data
  if (variants.length === 0) {
    throw createParseError('No valid variants found in file. Please check the file format.');
  }

  // Warn if many errors (but still return results)
  if (errors.length > 100) {
    console.warn(`Parser encountered ${errors.length} unparseable lines`);
  }

  return {
    format: '23andme-v5',
    variants,
    metadata: {
      generatedAt,
      build,
    },
  };
}

/**
 * Parse a single data line
 * Format: rsid\tchromosome\tposition\tgenotype
 */
function parseDataLine(line: string): GenomeVariant | null {
  // Split by tab
  const parts = line.split('\t');

  if (parts.length < 4) {
    return null;
  }

  const [rsid, chromosome, positionStr, genotype] = parts;

  // Validate rsid (should start with 'rs' or 'i' for internal IDs)
  if (!rsid || (!rsid.startsWith('rs') && !rsid.startsWith('i'))) {
    return null;
  }

  // Validate chromosome
  if (!chromosome || !isValidChromosome(chromosome)) {
    return null;
  }

  // Parse position
  const position = parseInt(positionStr ?? '', 10);
  if (isNaN(position) || position < 0) {
    return null;
  }

  // Validate genotype
  if (!genotype || !isValidGenotype(genotype)) {
    return null;
  }

  return {
    rsid: rsid.toLowerCase(), // Normalize to lowercase
    chromosome: normalizeChromosome(chromosome),
    position,
    genotype: genotype.toUpperCase(), // Normalize to uppercase
  };
}

/**
 * Check if chromosome value is valid
 */
function isValidChromosome(chr: string): boolean {
  const normalized = chr.toUpperCase();
  // Autosomes 1-22, sex chromosomes X/Y, mitochondrial MT
  if (/^[1-9]$|^1[0-9]$|^2[0-2]$/.test(normalized)) return true;
  if (['X', 'Y', 'MT', 'M'].includes(normalized)) return true;
  return false;
}

/**
 * Normalize chromosome representation
 */
function normalizeChromosome(chr: string): string {
  const upper = chr.toUpperCase();
  if (upper === 'M') return 'MT';
  return upper;
}

/**
 * Check if genotype value is valid
 */
function isValidGenotype(genotype: string): boolean {
  // No-call
  if (genotype === '--') return true;

  // Single nucleotide (for hemizygous X/Y in males)
  if (/^[ACGT]$/.test(genotype.toUpperCase())) return true;

  // Diploid genotype
  if (/^[ACGT]{2}$/.test(genotype.toUpperCase())) return true;

  // Insertions/deletions (I/D notation)
  if (/^[DI]{1,2}$/.test(genotype.toUpperCase())) return true;

  return false;
}

/**
 * Create a ParseError
 */
function createParseError(message: string, line?: number, details?: string): ParseError {
  return { message, line, details };
}
